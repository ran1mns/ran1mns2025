<section class="course">
  <h1>Titre du Cours : Cours Culture et Méthodologie – 13 Octobre 2025</h1>
  <article class="concepts">
    <h2>Numérotation</h2>
    <p>On utilise les phalanges pour compter : jusqu’à 12, puis sur les 10 doigts (1 à 10), puis le zéro.</p>
<h3>Décimal</h3>
<p>Exemple : 1234 (sur 4 chiffres, on a 10⁴ = 10000 possibilités, de 0 à 9 sur chaque chiffre).</p>
<pre><code class="language-none">
1*10^3 + 2*10^2 + 3*10^1 + 4*10^0
1000 + 200 + 30 + 4
</code></pre>
<p>En informatique, on se limite souvent à 0 et 1.</p>
  </article>
  <article class="concepts">
    <h2>Numération binaire et hexadécimal</h2>
    <h3>Compter en binaire</h3>
<p>Exemple : 10101101 en base 2 :</p>
<pre><code class="language-none">
2^7 + 0 + 2^5 + 0 + 2^3 + 2^2 + 0 + 2^0
128 + 0 + 32 + 0 + 8 + 4 + 0 + 1 = 173
</code></pre>
<h3>Groupement et hexadécimal</h3>
<p>On regroupe les bits par 4 (quartet) → 16 combinaisons possibles. Sur 8 bits (octet) : 0 à 255.</p>
<p>Pour les valeurs 10 à 15, on utilise l’hexadécimal : 0–9 = chiffres habituels, 10–15 = A B C D E F. Cela permet de réduire la longueur des notations.</p>
  </article>
  <article class="concepts">
    <h2>Outil de conversion Binaire/Décimal en Python</h2>
    <pre><code class="language-python">
nb_binaire = input("Entrez un nombre binaire à base de 0 et 1 ! ")

liste_bits = [int(bit) for bit in nb_binaire]

print(liste_bits)

max_len = len(liste_bits)
maxweight = int((2**max_len)/2)

print(max_len)
print(maxweight)

sumtotal = 0
while maxweight &gt;= 1:
    for index, bit in enumerate(liste_bits):
        sum = bit * maxweight
        maxweight = maxweight / 2
        sumtotal = sumtotal + sum

print(f"Le poids du nombre binaire maximal est {int((2**max_len)/2)}")
print(f"Le nombre binaire {nb_binaire} est égal à {int(sumtotal)}")
</code></pre>
  </article>
  <article class="concepts">
    <h2>Chronologie des langages et Framework</h2>
    <h3>Langages</h3>
<ul>
<li>Assembly : proche du processeur</li>
<li>Fortran : 1957</li>
<li>Lisp (IA) : 1958</li>
<li>Cobol (banque) : 1959</li>
<li>BASIC : 1960-64</li>
<li>Pascal : 1970</li>
<li>C : 1972</li>
<li>SQL : 1978</li>
<li>Ada : 1980</li>
<li>C++ : 1983</li>
<li>Python, Visual Basic : 1991</li>
<li>Java, PHP, Ruby : 1995</li>
<li>C# : 2000</li>
<li>Go : 2009</li>
<li>Rust : 2010</li>
<li>Kotlin : 2011</li>
<li>Rien de nouveau depuis 2014</li>
</ul>
<h3>Frameworks</h3>
<ul>
<li>Ruby on Rails : 2004</li>
<li>Django : 2005</li>
<li>Symfony : 2005</li>
<li>Express JS / Node JS : 2010</li>
<li>jQuery : 2006</li>
<li>Angular : 2010</li>
<li>React : 2013</li>
<li>Vue.js : 2014</li>
</ul>
  </article>
  <article class="concepts">
    <h2>Futur de l’informatique</h2>
    <p>Rien de concret à l’horizon : le futur, c’est nous !</p>
  </article>
</section>